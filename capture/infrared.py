#!/usr/bin/env python3
# Monitor, capture and decode InfraRed signal (of an IR remote controller) 
# Version:  v1.0
# Author: Nikola Jovanovic
# Date: 13.09.2020.
# Repo: https://github.com/etfovac/rpi_ir
# SW: Python 3.7.3
# HW: Pi Model 3B  V1.2, IR kit: Rx sensor module HX1838, Tx = IR remote(s)
import pigpio
import ir_format

class rx:
    """
    This class captures and decodes the IR pulses generated by an IR remote.

    Reference:
    http://abyz.me.uk/rpi/pigpio/examples.html#Python%20code (ir_hasher.py - it does not detect bits of message)
    http://abyz.me.uk/rpi/pigpio/python.html#callback
    http://abyz.me.uk/rpi/pigpio/python.html#set_watchdog

    The GPIO are sampled at a rate set when the pigpio daemon is started (default 5 us).

    GPIO level changes shorter than the sample rate may be missed.

    The daemon software which generates the callbacks is triggered 1000 times per second.
    The callbacks will be called once per level change since the last time they were called.
    i.e. The callbacks will get all level changes but there will be a latency.

    tick, 32 bit, The number of microseconds since boot
    WARNING: tick wraps around from 4294967295 to 0 roughly every 72 minutes
    """

    def __init__(self, pi, gpio, external_callback, timeout=5):
        """
        Init an IR remote recorder. A gap of timeout ms indicates the end of the remote key press.
        """
        self.pi = pi
        self.gpio = gpio
        self.watchdog_timeout = timeout
        self.callback = external_callback
        self.edges = 0
        self.rec_started = False
        pi.set_pull_up_down(gpio, pigpio.PUD_OFF)
        pi.set_mode(gpio, pigpio.INPUT)
        self.cb = pi.callback(gpio, pigpio.EITHER_EDGE, self.rx_callback)
        self.d1a = []
        self.d2a = []
        self.threshold01 = sum(ir_format.ir_format['bit1'])*ir_format.tolerance['down']
        self.valid_code = False

    def rx_callback(self, gpio, level, tick):
        if level != pigpio.TIMEOUT:
            if self.rec_started == False:
                self.rec_started = True # first edge detected
                self.pi.set_watchdog(self.gpio, self.watchdog_timeout)
                self.ir_decoded = ""
                self.edges = 1
                self.d1a = []
                self.d2a = []
                self.t1 = None
                self.t2 = None
                self.t3 = tick # latest edge time stamp
            else:
                self.edges += 1
                self.t1 = self.t2
                self.t2 = self.t3
                self.t3 = tick
                if self.edges == 2:
                   if pigpio.tickDiff(self.t2,self.t3) > ir_format.ir_format['header'][1]*ir_format.tolerance['down']:
                       self.edges -= 1
                if self.edges %2 == 1 and self.edges >1:
                   d1 = pigpio.tickDiff(self.t1,self.t2)
                   d2 = pigpio.tickDiff(self.t2,self.t3)
                   if (d1+d2)>self.threshold01: val = "1"
                   else: val = "0"
                   self.d1a.append({d2,d1})  # monitor
                   self.d2a.append(int(val)) # monitor
                   self.ir_decoded += val
        else: # timeouted
                if self.rec_started: # signal catched
                    self.rec_started = False
                    self.pi.set_watchdog(self.gpio, 0) # stops watchdog
                if self.edges > 2*ir_format.ir_format['data_len']: # ignore glitches and repeates
                    self.valid_code = len(self.ir_decoded)==ir_format.ir_format['data_len']
                    self.callback(self.ir_decoded, hex(int(self.ir_decoded,2)), self.valid_code) # return the detected IR signal to external callback
                #print(self.edges) #66
                #print("d1a={}\nlen={}".format(self.d1a,len(self.d1a))) # sometimes signals are inverted in time
                #print("d2a={}\nlen={}".format(self.d2a,len(self.d2a)))
